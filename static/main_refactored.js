/**\n * 리팩토링된 메인 애플리케이션 컨트롤러\n * utils.js의 공통 기능을 활용하여 개선\n */\nclass ConfluenceController {\n    constructor() {\n        this.connectionStatus = false;\n        this.currentTaskId = null;\n        this.statusCheckInterval = null;\n        this.mindmapModalManager = null;\n        \n        // utils.js 인스턴스 참조\n        this.api = window.ConfluenceAuto.api;\n        this.notify = window.ConfluenceAuto.notify;\n        this.loading = window.ConfluenceAuto.loading;\n        \n        this.init();\n    }\n    \n    init() {\n        this.bindEvents();\n        this.initMindmapModal();\n        this.loadSavedSettings();\n        this.updateLog(\"시스템 초기화 완료\");\n    }\n    \n    /**\n     * 이벤트 바인딩\n     */\n    bindEvents() {\n        // 연결 테스트\n        const testConnectionBtn = document.getElementById('testConnection');\n        if (testConnectionBtn) {\n            testConnectionBtn.addEventListener('click', \n                window.ConfluenceAuto.DOMUtils.debounce(() => this.testConnection(), 500)\n            );\n        }\n        \n        // 페이지 처리 폼\n        const processForm = document.getElementById('processForm');\n        if (processForm) {\n            processForm.addEventListener('submit', (e) => this.processPages(e));\n        }\n        \n        // 결과 다운로드\n        const downloadResultsBtn = document.getElementById('downloadResults');\n        if (downloadResultsBtn) {\n            downloadResultsBtn.addEventListener('click', () => this.downloadResults());\n        }\n        \n        // 설정 저장\n        this.bindSettingsEvents();\n        \n        // 마인드맵 관련 이벤트는 DOMContentLoaded 후 처리\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this.bindMindmapEvents());\n        } else {\n            this.bindMindmapEvents();\n        }\n    }\n    \n    /**\n     * 설정 관련 이벤트 바인딩\n     */\n    bindSettingsEvents() {\n        const settingsFields = ['confluenceUrl', 'username', 'password'];\n        \n        settingsFields.forEach(fieldId => {\n            const field = document.getElementById(fieldId);\n            if (field) {\n                field.addEventListener('input', \n                    window.ConfluenceAuto.DOMUtils.debounce(() => this.saveSettings(), 1000)\n                );\n            }\n        });\n    }\n    \n    /**\n     * 마인드맵 관련 이벤트 바인딩\n     */\n    bindMindmapEvents() {\n        // 헤더의 마인드맵 버튼들\n        const mindmapButtons = {\n            'viewAllMindmap': () => this.viewAllMindmap(),\n            'viewSpecificMindmap': () => this.viewSpecificMindmap(),\n            'viewKeywordMindmap': () => this.viewKeywordMindmap()\n        };\n        \n        Object.entries(mindmapButtons).forEach(([buttonId, handler]) => {\n            const button = document.getElementById(buttonId);\n            if (button) {\n                button.addEventListener('click', handler);\n            }\n        });\n    }\n    \n    /**\n     * 마인드맵 모달 초기화\n     */\n    initMindmapModal() {\n        this.mindmapModalManager = new MindmapModalManager();\n    }\n    \n    /**\n     * 저장된 설정 불러오기\n     */\n    loadSavedSettings() {\n        const savedSettings = window.ConfluenceAuto.StorageUtils.get('confluence_settings', {});\n        \n        if (savedSettings.confluenceUrl) {\n            const urlField = document.getElementById('confluenceUrl');\n            if (urlField) urlField.value = savedSettings.confluenceUrl;\n        }\n        \n        if (savedSettings.username) {\n            const usernameField = document.getElementById('username');\n            if (usernameField) usernameField.value = savedSettings.username;\n        }\n        \n        this.updateLog(\"저장된 설정을 불러왔습니다.\");\n    }\n    \n    /**\n     * 설정 저장\n     */\n    saveSettings() {\n        const settings = {\n            confluenceUrl: document.getElementById('confluenceUrl')?.value || '',\n            username: document.getElementById('username')?.value || ''\n            // 패스워드는 보안상 저장하지 않음\n        };\n        \n        window.ConfluenceAuto.StorageUtils.set('confluence_settings', settings);\n    }\n    \n    /**\n     * Confluence 연결 테스트\n     */\n    async testConnection() {\n        const connectionForm = document.getElementById('connectionForm');\n        if (!connectionForm) return;\n        \n        // 폼 유효성 검사\n        const validation = window.ConfluenceAuto.FormUtils.validateForm(connectionForm);\n        if (!validation.isValid) {\n            const errorMessages = validation.errors.map(error => error.message).join('\\n');\n            this.notify.error(errorMessages);\n            return;\n        }\n        \n        const formData = window.ConfluenceAuto.FormUtils.formToObject(connectionForm);\n        \n        this.loading.start('connection_test');\n        this.updateLog(\"Confluence 연결 테스트 중...\");\n        \n        try {\n            const result = await this.api.post('/test-connection', {\n                url: formData.confluenceUrl,\n                username: formData.username,\n                password: formData.password\n            });\n            \n            if (result.status === 'success') {\n                this.connectionStatus = true;\n                this.notify.success('Confluence 연결 성공!');\n                this.updateLog(`연결 성공: ${result.message}`);\n                this.updateConnectionUI(true);\n                \n                // 사용자 정보가 있으면 표시\n                if (result.user_info) {\n                    this.updateLog(`사용자: ${result.user_info.displayName || result.user_info.name}`);\n                }\n            } else {\n                throw new Error(result.message || '연결 실패');\n            }\n        } catch (error) {\n            this.connectionStatus = false;\n            this.notify.error(error.getUserMessage());\n            this.updateLog(`연결 실패: ${error.message}`);\n            this.updateConnectionUI(false);\n        } finally {\n            this.loading.stop('connection_test');\n        }\n    }\n    \n    /**\n     * 연결 상태 UI 업데이트\n     */\n    updateConnectionUI(isConnected) {\n        const statusIndicator = document.getElementById('connectionStatus');\n        const processSection = document.getElementById('processSection');\n        \n        if (statusIndicator) {\n            statusIndicator.className = isConnected ? 'status-success' : 'status-error';\n            statusIndicator.textContent = isConnected ? '연결됨' : '연결 안됨';\n        }\n        \n        if (processSection) {\n            processSection.style.display = isConnected ? 'block' : 'none';\n        }\n    }\n    \n    /**\n     * 페이지 처리 시작\n     */\n    async processPages(event) {\n        event.preventDefault();\n        \n        if (!this.connectionStatus) {\n            this.notify.warning('먼저 Confluence 연결을 테스트해주세요.');\n            return;\n        }\n        \n        const processForm = document.getElementById('processForm');\n        const validation = window.ConfluenceAuto.FormUtils.validateForm(processForm);\n        \n        if (!validation.isValid) {\n            const errorMessages = validation.errors.map(error => error.message).join('\\n');\n            this.notify.error(errorMessages);\n            return;\n        }\n        \n        const formData = window.ConfluenceAuto.FormUtils.formToObject(processForm);\n        const connectionData = window.ConfluenceAuto.FormUtils.formToObject(\n            document.getElementById('connectionForm')\n        );\n        \n        this.loading.start('page_processing');\n        this.updateLog(\"페이지 처리 시작...\");\n        \n        try {\n            const response = await this.api.post(`/process-pages/${formData.parentPageId}`, {\n                confluence_url: connectionData.confluenceUrl,\n                username: connectionData.username,\n                password: connectionData.password\n            });\n            \n            this.currentTaskId = response.task_id;\n            this.notify.success('페이지 처리가 시작되었습니다.');\n            this.updateLog(`작업 ID: ${this.currentTaskId}`);\n            \n            // 상태 모니터링 시작\n            this.startStatusMonitoring();\n            \n        } catch (error) {\n            this.notify.error(error.getUserMessage());\n            this.updateLog(`처리 실패: ${error.message}`);\n        } finally {\n            this.loading.stop('page_processing');\n        }\n    }\n    \n    /**\n     * 상태 모니터링 시작\n     */\n    startStatusMonitoring() {\n        if (this.statusCheckInterval) {\n            clearInterval(this.statusCheckInterval);\n        }\n        \n        this.statusCheckInterval = setInterval(async () => {\n            try {\n                await this.checkTaskStatus();\n            } catch (error) {\n                console.error('상태 확인 오류:', error);\n            }\n        }, 2000);\n    }\n    \n    /**\n     * 작업 상태 확인\n     */\n    async checkTaskStatus() {\n        if (!this.currentTaskId) return;\n        \n        try {\n            const status = await this.api.get(`/status/${this.currentTaskId}`);\n            \n            this.updateProgressUI(status);\n            \n            if (status.status === 'completed') {\n                this.handleProcessingComplete(status);\n            } else if (status.status === 'failed') {\n                this.handleProcessingFailed(status);\n            }\n        } catch (error) {\n            console.error('상태 확인 실패:', error);\n        }\n    }\n    \n    /**\n     * 진행 상태 UI 업데이트\n     */\n    updateProgressUI(status) {\n        const progressBar = document.getElementById('progressBar');\n        const progressText = document.getElementById('progressText');\n        \n        if (status.progress) {\n            const percentage = status.progress.total > 0 \n                ? Math.round((status.progress.completed / status.progress.total) * 100)\n                : 0;\n            \n            if (progressBar) {\n                progressBar.style.width = `${percentage}%`;\n            }\n            \n            if (progressText) {\n                progressText.textContent = \n                    `${status.progress.completed}/${status.progress.total} (${percentage}%)`;\n            }\n            \n            this.updateLog(\n                `진행 상황: ${status.progress.completed}/${status.progress.total} (${percentage}%)`\n            );\n        }\n    }\n    \n    /**\n     * 처리 완료 핸들링\n     */\n    handleProcessingComplete(status) {\n        clearInterval(this.statusCheckInterval);\n        this.statusCheckInterval = null;\n        \n        this.notify.success('모든 페이지 처리가 완료되었습니다!');\n        this.updateLog(\"처리 완료!\");\n        \n        // 결과 섹션 표시\n        const resultSection = document.getElementById('resultSection');\n        if (resultSection) {\n            resultSection.style.display = 'block';\n        }\n        \n        this.currentTaskId = null;\n    }\n    \n    /**\n     * 처리 실패 핸들링\n     */\n    handleProcessingFailed(status) {\n        clearInterval(this.statusCheckInterval);\n        this.statusCheckInterval = null;\n        \n        this.notify.error('페이지 처리 중 오류가 발생했습니다.');\n        this.updateLog(`처리 실패: ${status.error || '알 수 없는 오류'}`);\n        \n        this.currentTaskId = null;\n    }\n    \n    /**\n     * 전체 마인드맵 보기\n     */\n    async viewAllMindmap() {\n        this.loading.start('mindmap_loading');\n        \n        try {\n            this.mindmapModalManager.show('전체 페이지 마인드맵', () => {\n                return this.loadAllMindmap();\n            });\n        } catch (error) {\n            this.notify.error('마인드맵을 불러오는데 실패했습니다.');\n        } finally {\n            this.loading.stop('mindmap_loading');\n        }\n    }\n    \n    /**\n     * 특정 페이지 마인드맵 보기\n     */\n    viewSpecificMindmap() {\n        this.mindmapModalManager.showPageSelector(async (pageId) => {\n            this.loading.start('mindmap_loading');\n            \n            try {\n                return await this.loadSpecificMindmap(pageId);\n            } catch (error) {\n                this.notify.error('마인드맵을 불러오는데 실패했습니다.');\n                throw error;\n            } finally {\n                this.loading.stop('mindmap_loading');\n            }\n        });\n    }\n    \n    /**\n     * 키워드 기반 마인드맵 보기\n     */\n    async viewKeywordMindmap() {\n        this.mindmapModalManager.showKeywordSelector(async (keyword) => {\n            this.loading.start('mindmap_loading');\n            \n            try {\n                return await this.loadKeywordMindmap(keyword);\n            } catch (error) {\n                this.notify.error('마인드맵을 불러오는데 실패했습니다.');\n                throw error;\n            } finally {\n                this.loading.stop('mindmap_loading');\n            }\n        });\n    }\n    \n    /**\n     * 전체 마인드맵 데이터 로드\n     */\n    async loadAllMindmap() {\n        const data = await this.api.get('/mindmap-all', {\n            threshold: 0.3,\n            limit: 100\n        });\n        return data;\n    }\n    \n    /**\n     * 특정 페이지 마인드맵 데이터 로드\n     */\n    async loadSpecificMindmap(pageId) {\n        const data = await this.api.get(`/mindmap/${pageId}`, {\n            threshold: 0.3,\n            max_depth: 3\n        });\n        return data;\n    }\n    \n    /**\n     * 키워드 마인드맵 데이터 로드\n     */\n    async loadKeywordMindmap(keyword) {\n        const data = await this.api.get('/mindmap-keyword', {\n            keyword: keyword,\n            threshold: 0.3,\n            limit: 100\n        });\n        return data;\n    }\n    \n    /**\n     * 결과 다운로드\n     */\n    async downloadResults() {\n        this.loading.start('download');\n        \n        try {\n            const pages = await this.api.get('/pages', { per_page: 1000 });\n            \n            const csvContent = this.generateCSV(pages.pages);\n            this.downloadFile(csvContent, 'confluence_summary.csv', 'text/csv');\n            \n            this.notify.success('결과가 다운로드되었습니다.');\n        } catch (error) {\n            this.notify.error('다운로드에 실패했습니다.');\n        } finally {\n            this.loading.stop('download');\n        }\n    }\n    \n    /**\n     * CSV 생성\n     */\n    generateCSV(pages) {\n        const headers = ['페이지 ID', '제목', '요약', '키워드', 'URL'];\n        const rows = pages.map(page => [\n            page.page_id,\n            `\"${page.title.replace(/\"/g, '\"\"')}\"`,\n            `\"${page.summary.replace(/\"/g, '\"\"')}\"`,\n            `\"${page.keywords.join(', ')}\"`,\n            page.url\n        ]);\n        \n        return [headers, ...rows].map(row => row.join(',')).join('\\n');\n    }\n    \n    /**\n     * 파일 다운로드\n     */\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        \n        const link = document.createElement('a');\n        link.href = url;\n        link.download = filename;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        URL.revokeObjectURL(url);\n    }\n    \n    /**\n     * 로그 업데이트\n     */\n    updateLog(message) {\n        const logArea = document.getElementById('logArea');\n        if (logArea) {\n            const timestamp = new Date().toLocaleTimeString();\n            logArea.value += `[${timestamp}] ${message}\\n`;\n            logArea.scrollTop = logArea.scrollHeight;\n        }\n        console.log(`[ConfluenceAuto] ${message}`);\n    }\n}\n\n/**\n * 마인드맵 모달 관리자\n */\nclass MindmapModalManager {\n    constructor() {\n        this.currentModal = null;\n        this.init();\n    }\n    \n    init() {\n        this.createModalHTML();\n        this.bindEvents();\n    }\n    \n    createModalHTML() {\n        const modalHTML = `\n            <div id=\"mindmapModal\" class=\"modal\" style=\"display: none;\">\n                <div class=\"modal-content\">\n                    <div class=\"modal-header\">\n                        <h3 id=\"mindmapModalTitle\">마인드맵</h3>\n                        <span class=\"close\" id=\"closeMindmapModal\">&times;</span>\n                    </div>\n                    <div class=\"modal-body\">\n                        <div id=\"mindmapModalContent\">\n                            <!-- 마인드맵 내용이 여기에 로드됩니다 -->\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n        \n        document.body.insertAdjacentHTML('beforeend', modalHTML);\n    }\n    \n    bindEvents() {\n        const modal = document.getElementById('mindmapModal');\n        const closeBtn = document.getElementById('closeMindmapModal');\n        \n        if (closeBtn) {\n            closeBtn.addEventListener('click', () => this.hide());\n        }\n        \n        if (modal) {\n            modal.addEventListener('click', (e) => {\n                if (e.target === modal) {\n                    this.hide();\n                }\n            });\n        }\n        \n        // ESC 키로 모달 닫기\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape' && this.currentModal) {\n                this.hide();\n            }\n        });\n    }\n    \n    show(title, dataLoader) {\n        const modal = document.getElementById('mindmapModal');\n        const titleElement = document.getElementById('mindmapModalTitle');\n        const contentElement = document.getElementById('mindmapModalContent');\n        \n        if (titleElement) titleElement.textContent = title;\n        if (contentElement) contentElement.innerHTML = '<div class=\"loading\">마인드맵을 불러오는 중...</div>';\n        \n        if (modal) {\n            modal.style.display = 'block';\n            this.currentModal = modal;\n        }\n        \n        // 데이터 로드 및 마인드맵 생성\n        dataLoader().then(data => {\n            if (contentElement) {\n                contentElement.innerHTML = '<div id=\"mindmapVisualization\"></div>';\n                this.createMindmapVisualization(data);\n            }\n        }).catch(error => {\n            if (contentElement) {\n                contentElement.innerHTML = '<div class=\"error\">마인드맵을 불러오는데 실패했습니다.</div>';\n            }\n        });\n    }\n    \n    hide() {\n        const modal = document.getElementById('mindmapModal');\n        if (modal) {\n            modal.style.display = 'none';\n            this.currentModal = null;\n        }\n    }\n    \n    showPageSelector(onPageSelected) {\n        // 페이지 선택 모달 구현\n        // 실제 구현에서는 페이지 목록을 가져와서 선택할 수 있도록 함\n        const pageId = prompt('마인드맵을 생성할 페이지 ID를 입력하세요:');\n        if (pageId) {\n            this.show(`페이지 ${pageId} 마인드맵`, () => onPageSelected(pageId));\n        }\n    }\n    \n    showKeywordSelector(onKeywordSelected) {\n        // 키워드 선택 모달 구현\n        const keyword = prompt('마인드맵을 생성할 키워드를 입력하세요:');\n        if (keyword) {\n            this.show(`키워드 \"${keyword}\" 마인드맵`, () => onKeywordSelected(keyword));\n        }\n    }\n    \n    createMindmapVisualization(data) {\n        // 기존 mindmap.js의 시각화 로직 사용\n        // 이 부분은 mindmap.js와 통합하거나 별도 모듈로 분리할 수 있음\n        if (window.createSimpleVisualization) {\n            window.createSimpleVisualization(data.nodes, data.links);\n        }\n    }\n}\n\n// 전역 변수로 컨트롤러 인스턴스 생성\nlet confluenceController;\n\n// DOM 로드 완료 후 초기화\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n        confluenceController = new ConfluenceController();\n    });\n} else {\n    confluenceController = new ConfluenceController();\n}\n\n// 전역 접근을 위한 export\nwindow.ConfluenceController = ConfluenceController;\nwindow.confluenceController = confluenceController;"