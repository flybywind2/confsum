/**\n * 공통 유틸리티 함수들\n */\n\n/**\n * API 클라이언트 클래스\n * 모든 API 호출을 표준화하고 에러 처리를 일관성 있게 수행\n */\nclass APIClient {\n    constructor(baseURL = '') {\n        this.baseURL = baseURL;\n        this.defaultHeaders = {\n            'Content-Type': 'application/json'\n        };\n    }\n\n    /**\n     * HTTP 요청 수행\n     * @param {string} url - 요청 URL\n     * @param {Object} options - fetch 옵션\n     * @returns {Promise<Object>} - 응답 데이터\n     */\n    async request(url, options = {}) {\n        const config = {\n            headers: {\n                ...this.defaultHeaders,\n                ...options.headers\n            },\n            ...options\n        };\n\n        const fullURL = this.baseURL + url;\n        \n        try {\n            console.log(`API 요청: ${config.method || 'GET'} ${fullURL}`);\n            \n            const response = await fetch(fullURL, config);\n            \n            if (!response.ok) {\n                const errorData = await this.handleErrorResponse(response);\n                throw new APIError(\n                    errorData.message || `HTTP ${response.status}`,\n                    response.status,\n                    errorData\n                );\n            }\n\n            const contentType = response.headers.get('content-type');\n            if (contentType && contentType.includes('application/json')) {\n                return await response.json();\n            }\n            \n            return await response.text();\n        } catch (error) {\n            if (error instanceof APIError) {\n                throw error;\n            }\n            \n            console.error('API 요청 실패:', error);\n            throw new APIError(\n                '네트워크 오류가 발생했습니다.',\n                0,\n                { originalError: error.message }\n            );\n        }\n    }\n\n    /**\n     * 에러 응답 처리\n     * @param {Response} response - fetch 응답\n     * @returns {Promise<Object>} - 에러 데이터\n     */\n    async handleErrorResponse(response) {\n        try {\n            const contentType = response.headers.get('content-type');\n            if (contentType && contentType.includes('application/json')) {\n                return await response.json();\n            }\n            return { message: await response.text() };\n        } catch {\n            return { message: `HTTP ${response.status} ${response.statusText}` };\n        }\n    }\n\n    /**\n     * GET 요청\n     */\n    async get(url, params = {}) {\n        const queryString = new URLSearchParams(params).toString();\n        const fullURL = queryString ? `${url}?${queryString}` : url;\n        \n        return this.request(fullURL, { method: 'GET' });\n    }\n\n    /**\n     * POST 요청\n     */\n    async post(url, data = null) {\n        const options = { method: 'POST' };\n        \n        if (data) {\n            options.body = JSON.stringify(data);\n        }\n        \n        return this.request(url, options);\n    }\n\n    /**\n     * PUT 요청\n     */\n    async put(url, data = null) {\n        const options = { method: 'PUT' };\n        \n        if (data) {\n            options.body = JSON.stringify(data);\n        }\n        \n        return this.request(url, options);\n    }\n\n    /**\n     * DELETE 요청\n     */\n    async delete(url) {\n        return this.request(url, { method: 'DELETE' });\n    }\n}\n\n/**\n * API 에러 클래스\n */\nclass APIError extends Error {\n    constructor(message, statusCode = 0, details = {}) {\n        super(message);\n        this.name = 'APIError';\n        this.statusCode = statusCode;\n        this.details = details;\n    }\n\n    /**\n     * 사용자 친화적 에러 메시지 반환\n     */\n    getUserMessage() {\n        if (this.statusCode >= 500) {\n            return '서버에 일시적인 문제가 발생했습니다. 잠시 후 다시 시도해주세요.';\n        } else if (this.statusCode >= 400) {\n            return this.message || '요청에 문제가 있습니다.';\n        } else {\n            return '네트워크 연결을 확인해주세요.';\n        }\n    }\n}\n\n/**\n * 로딩 상태 관리 클래스\n */\nclass LoadingManager {\n    constructor() {\n        this.loadingStates = new Set();\n        this.loadingElement = null;\n        this.init();\n    }\n\n    init() {\n        // 글로벌 로딩 인디케이터 생성\n        this.loadingElement = document.createElement('div');\n        this.loadingElement.id = 'global-loading';\n        this.loadingElement.innerHTML = `\n            <div class=\"loading-backdrop\">\n                <div class=\"loading-spinner\">\n                    <div class=\"spinner\"></div>\n                    <p>처리 중...</p>\n                </div>\n            </div>\n        `;\n        this.loadingElement.style.display = 'none';\n        document.body.appendChild(this.loadingElement);\n    }\n\n    /**\n     * 로딩 시작\n     * @param {string} key - 로딩 식별키\n     */\n    start(key = 'default') {\n        this.loadingStates.add(key);\n        this.updateDisplay();\n    }\n\n    /**\n     * 로딩 종료\n     * @param {string} key - 로딩 식별키\n     */\n    stop(key = 'default') {\n        this.loadingStates.delete(key);\n        this.updateDisplay();\n    }\n\n    /**\n     * 로딩 디스플레이 업데이트\n     */\n    updateDisplay() {\n        if (this.loadingStates.size > 0) {\n            this.loadingElement.style.display = 'flex';\n        } else {\n            this.loadingElement.style.display = 'none';\n        }\n    }\n\n    /**\n     * 모든 로딩 상태 정리\n     */\n    clear() {\n        this.loadingStates.clear();\n        this.updateDisplay();\n    }\n}\n\n/**\n * 알림 메시지 관리 클래스\n */\nclass NotificationManager {\n    constructor() {\n        this.container = null;\n        this.init();\n    }\n\n    init() {\n        this.container = document.createElement('div');\n        this.container.id = 'notification-container';\n        this.container.className = 'notification-container';\n        document.body.appendChild(this.container);\n    }\n\n    /**\n     * 알림 표시\n     * @param {string} message - 메시지\n     * @param {string} type - 타입 (success, error, warning, info)\n     * @param {number} duration - 표시 시간 (ms)\n     */\n    show(message, type = 'info', duration = 5000) {\n        const notification = document.createElement('div');\n        notification.className = `notification notification-${type}`;\n        notification.innerHTML = `\n            <div class=\"notification-content\">\n                <span class=\"notification-message\">${message}</span>\n                <button class=\"notification-close\" onclick=\"this.parentElement.parentElement.remove()\">&times;</button>\n            </div>\n        `;\n\n        this.container.appendChild(notification);\n\n        // 애니메이션 효과\n        requestAnimationFrame(() => {\n            notification.classList.add('show');\n        });\n\n        // 자동 제거\n        if (duration > 0) {\n            setTimeout(() => {\n                this.remove(notification);\n            }, duration);\n        }\n\n        return notification;\n    }\n\n    /**\n     * 알림 제거\n     */\n    remove(notification) {\n        if (notification && notification.parentElement) {\n            notification.classList.add('hide');\n            setTimeout(() => {\n                if (notification.parentElement) {\n                    notification.remove();\n                }\n            }, 300);\n        }\n    }\n\n    /**\n     * 성공 메시지\n     */\n    success(message, duration = 3000) {\n        return this.show(message, 'success', duration);\n    }\n\n    /**\n     * 에러 메시지\n     */\n    error(message, duration = 5000) {\n        return this.show(message, 'error', duration);\n    }\n\n    /**\n     * 경고 메시지\n     */\n    warning(message, duration = 4000) {\n        return this.show(message, 'warning', duration);\n    }\n\n    /**\n     * 정보 메시지\n     */\n    info(message, duration = 3000) {\n        return this.show(message, 'info', duration);\n    }\n\n    /**\n     * 모든 알림 제거\n     */\n    clear() {\n        const notifications = this.container.querySelectorAll('.notification');\n        notifications.forEach(notification => this.remove(notification));\n    }\n}\n\n/**\n * 폼 유틸리티 클래스\n */\nclass FormUtils {\n    /**\n     * 폼 데이터를 객체로 변환\n     * @param {HTMLFormElement} form - 폼 엘리먼트\n     * @returns {Object} - 폼 데이터 객체\n     */\n    static formToObject(form) {\n        const formData = new FormData(form);\n        const obj = {};\n        \n        for (const [key, value] of formData.entries()) {\n            if (obj[key]) {\n                // 동일한 name의 필드가 여러 개인 경우 배열로 처리\n                if (Array.isArray(obj[key])) {\n                    obj[key].push(value);\n                } else {\n                    obj[key] = [obj[key], value];\n                }\n            } else {\n                obj[key] = value;\n            }\n        }\n        \n        return obj;\n    }\n\n    /**\n     * 폼 유효성 검사\n     * @param {HTMLFormElement} form - 폼 엘리먼트\n     * @returns {Object} - 검사 결과\n     */\n    static validateForm(form) {\n        const errors = [];\n        const requiredFields = form.querySelectorAll('[required]');\n        \n        requiredFields.forEach(field => {\n            if (!field.value.trim()) {\n                errors.push({\n                    field: field.name || field.id,\n                    message: `${field.getAttribute('data-label') || field.name || '필드'}는 필수입니다.`\n                });\n            }\n        });\n        \n        // 이메일 검증\n        const emailFields = form.querySelectorAll('input[type=\"email\"]');\n        emailFields.forEach(field => {\n            if (field.value && !this.isValidEmail(field.value)) {\n                errors.push({\n                    field: field.name || field.id,\n                    message: '올바른 이메일 형식이 아닙니다.'\n                });\n            }\n        });\n        \n        // URL 검증\n        const urlFields = form.querySelectorAll('input[type=\"url\"]');\n        urlFields.forEach(field => {\n            if (field.value && !this.isValidURL(field.value)) {\n                errors.push({\n                    field: field.name || field.id,\n                    message: '올바른 URL 형식이 아닙니다.'\n                });\n            }\n        });\n        \n        return {\n            isValid: errors.length === 0,\n            errors: errors\n        };\n    }\n\n    /**\n     * 이메일 유효성 검사\n     */\n    static isValidEmail(email) {\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        return emailRegex.test(email);\n    }\n\n    /**\n     * URL 유효성 검사\n     */\n    static isValidURL(url) {\n        try {\n            new URL(url);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n\n/**\n * DOM 유틸리티 클래스\n */\nclass DOMUtils {\n    /**\n     * 요소가 뷰포트에 보이는지 확인\n     */\n    static isElementInViewport(element) {\n        const rect = element.getBoundingClientRect();\n        return (\n            rect.top >= 0 &&\n            rect.left >= 0 &&\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n        );\n    }\n\n    /**\n     * 요소로 부드럽게 스크롤\n     */\n    static scrollToElement(element, offset = 0) {\n        const elementPosition = element.offsetTop - offset;\n        window.scrollTo({\n            top: elementPosition,\n            behavior: 'smooth'\n        });\n    }\n\n    /**\n     * 디바운스 함수\n     */\n    static debounce(func, delay) {\n        let timeoutId;\n        return function (...args) {\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(() => func.apply(this, args), delay);\n        };\n    }\n\n    /**\n     * 스로틀 함수\n     */\n    static throttle(func, limit) {\n        let inThrottle;\n        return function (...args) {\n            if (!inThrottle) {\n                func.apply(this, args);\n                inThrottle = true;\n                setTimeout(() => inThrottle = false, limit);\n            }\n        };\n    }\n}\n\n/**\n * 로컬 스토리지 유틸리티 클래스\n */\nclass StorageUtils {\n    /**\n     * 로컬 스토리지에 데이터 저장\n     */\n    static set(key, value) {\n        try {\n            localStorage.setItem(key, JSON.stringify(value));\n            return true;\n        } catch (error) {\n            console.error('로컬 스토리지 저장 실패:', error);\n            return false;\n        }\n    }\n\n    /**\n     * 로컬 스토리지에서 데이터 가져오기\n     */\n    static get(key, defaultValue = null) {\n        try {\n            const item = localStorage.getItem(key);\n            return item ? JSON.parse(item) : defaultValue;\n        } catch (error) {\n            console.error('로컬 스토리지 읽기 실패:', error);\n            return defaultValue;\n        }\n    }\n\n    /**\n     * 로컬 스토리지에서 데이터 제거\n     */\n    static remove(key) {\n        try {\n            localStorage.removeItem(key);\n            return true;\n        } catch (error) {\n            console.error('로컬 스토리지 제거 실패:', error);\n            return false;\n        }\n    }\n\n    /**\n     * 로컬 스토리지 전체 초기화\n     */\n    static clear() {\n        try {\n            localStorage.clear();\n            return true;\n        } catch (error) {\n            console.error('로컬 스토리지 초기화 실패:', error);\n            return false;\n        }\n    }\n}\n\n// 전역 인스턴스 생성\nconst apiClient = new APIClient();\nconst loadingManager = new LoadingManager();\nconst notificationManager = new NotificationManager();\n\n// 전역 객체로 export\nwindow.ConfluenceAuto = {\n    APIClient,\n    APIError,\n    LoadingManager,\n    NotificationManager,\n    FormUtils,\n    DOMUtils,\n    StorageUtils,\n    \n    // 전역 인스턴스\n    api: apiClient,\n    loading: loadingManager,\n    notify: notificationManager\n};"